# ğŸ›°ï¸ FlyOS

**FlyOS** This is a lightweight operating system that integrates networking and security capabilities, supporting multiple control channels (REPL/REST/MCP). It communicates with daemons via **IPC** to achieve unified scheduling of network and security modules (routing/nic/acl/tunnel/nmap, etc.).

Its core objective is to provide a **unified, programmable, and scalable runtime environment** for **routing, switching, firewalls, data plane acceleration, and edge computing** on general-purpose devices.

### Control Channels

- **REPL (DSL)**: Interactive command line for operations personnel

- **REST API**: Suitable for UI, automation platforms, and DevOps/NetOps integration

- **MCP (JSON-RPC)**: For AI/LLM automated management and intelligent orchestration

Regardless of the control method used, all commands ultimately call daemons via **IPC (Unix Socket)**, and are executed by the **runtime.Manager** scheduling module, achieving unified management and efficient expansion of network and security policies.

---

# ğŸ“¦ Core Features

- Multiple control channels: REPL (DSL), REST API, MCP (JSON-RPC)
- Unified scheduling via IPC communication (Unix Socket)
- Modular network and security functions: routing, ACL, NAT, NIC, Tunnel, VRF, etc.
- Unified scheduling module: runtime.Manager
- Declarative configuration support for DSL
- Designed for automation and AI management

---

# ğŸ—ï¸ Project Structure
```
flyos/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ repl/
â”‚   â”œâ”€â”€ client/
â”‚   â””â”€â”€ daemon/
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ dsl/
â”‚   â”œâ”€â”€ runtime/
â”‚   â”œâ”€â”€ module/
â”‚   â”œâ”€â”€ ipc/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ routing/
â”‚   â”œâ”€â”€ acl/
â”‚   â”œâ”€â”€ nat/
â”‚   â”œâ”€â”€ nic/
â”‚   â”œâ”€â”€ tunnel/
â”‚   â””â”€â”€ vrf/
```
---

# ğŸ§  Overall Architecture Diagram

```mermaid
graph LR

    subgraph Clients
        direction TB
        REPL[REPL Client]
        CLI[CLI Tools]
        RESTC[REST Client]
        MCPC[MCP Client]
    end

    REPL -->|IPC-UNIX| DAEMON
    CLI  -->|IPC-UNIX| DAEMON
    RESTC -->|HTTP-JSON| REST
    MCPC  -->|WS-RPC| MCP

    DAEMON --> REST
    DAEMON --> MCP
    DAEMON --> RUNTIME

    subgraph DaemonInternal
        direction LR
        REST[REST Server]
        MCP[MCP Server]
        RUNTIME[runtime Manager]
        MODULES[Modules]
    end

    RUNTIME --> MODULES
```
---

# ğŸ”§ Installation Instructions

## 1. Cloning the Repository

```bash
git clone https://github.com/flystary/flyos.git
cd flyos
```

## 2. Compiling the Project

ç¡®ä¿ Go >= 1.20.0 ç¯å¢ƒï¼š

```bash
go build -o flyos ./main.go
go build -o flyos-daemon ./cmd/daemon/main.go
go build -o flyos-cli ./cmd/client/main.go
go build -o flyos-repl ./cmd/repl/main.go
```

## 3. Configuration

åˆ›å»º `config.toml` å’Œ `desc.toml`ï¼Œå¯å‚è€ƒç¤ºä¾‹ï¼š

```toml
[system]
hostname = "flyos-node"
```

```toml
[routes]
default = "192.168.1.1"
```

## 4. Start the daemon process

```bash
./flyos-daemon
```

---

# âš™ï¸ Usage Examples

## 1. Using REPL / DSL
```bash
root@flyos:~# ssh flyos
                __                             __
 _      _____  / /________  ____ ___  ___     / /_____
| | /| / / _ \/ / ___/ __ \/ __ `__ \/ _ \   / __/ __ \
| |/ |/ /  __/ / /__/ /_/ / / / / / /  __/  / /_/ /_/ /
|__/|__/\___/_/\___/\____/_/ /_/ /_/\___/   \__/\____/

         ________      ____  _____
        / ____/ /_  __/ __ \/ ___/
       / /_  / / / / / / / /\__ \
      / __/ / / /_/ / /_/ /___/ /
     /_/   /_/\__, /\____//____/
             /____/
ğŸ“„ desc.toml å·²åŠ è½½ï¼Œå…± 39 æ¡ğŸ“„å‘½ä»¤ï¼Œ9 ä¸ªğŸ—‚åˆ†ç±»
ğŸ”„ å·²åŠ è½½ 340 ä¸ªğŸ“¦å¤–éƒ¨å‘½ä»¤
ğŸš€ FlyOS REPL å·²å¯åŠ¨ï¼ğŸ’¡ è¾“å…¥ help æŸ¥çœ‹å‘½ä»¤ï¼Œè¾“å…¥ exit å®‰å…¨é€€å‡º
flyos> help
ğŸ› ï¸  å†…ç½®å‘½ä»¤:
  env        - æ‰“å°ç¯å¢ƒå˜é‡
  exit       - é€€å‡ºflyosç¯å¢ƒ
  help       - ğŸ” æ˜¾ç¤ºå‘½ä»¤æˆ–åˆ†ç±»çš„å¸®åŠ©ä¿¡æ¯ï¼ˆæ”¯æŒæ¨¡ç³Šæœç´¢ï¼‰
  list       - æ‰“å°å…¨éƒ¨å‘½ä»¤

ğŸ—‚  å¤–éƒ¨å‘½ä»¤åˆ†ç±»:
  arp
  nic
  pop
  route
  switch
  sys
  system
  tools
  vlan

ğŸ’¡ ä½¿ç”¨ `help [åˆ†ç±»å]` æŸ¥çœ‹åˆ†ç±»å†…å‘½ä»¤
flyos> exit
ğŸ‘‹ Bye!
Connection to 127.0.0.1 closed.
```

```bash
flyos> route add static { prefix 10.0.0.0/24; via 192.168.1.1; dev eth0; track yes }
flyos> route set static { prefix 10.0.0.0/24; via 192.168.1.1; dev eth0; track yes }
flyos> route delete static { prefix 10.0.0.0/24; via 192.168.1.1; dev eth0; track yes }
flyos> route sync {
	static { prefix 10.0.0.0/24; via 192.168.1.1; dev eth0; track yes }
	bgp { prefix 172.16.0.0/16; local_pref 200; community [ 65001:100 ] }
	ospf { prefix 192.168.10.0/24; area 0.0.0.0; type external }
	pbr { prefix 10.1.0.0/16; fwmark 100; priority 1000; iif eth1 }
	static { prefix 20.0.0.0/24; via 192.168.2.1; dev eth1; track yes }
    }
flyos>

```

## 2. Using REST API

```bash
curl -X POST http://localhost:8080/api/v1/route/add      -H "Content-Type: application/json"      -d '{"prefix":"10.0.0.0/24","via":"192.168.1.1"}'
```

## 3. Using MCP (JSON-RPC)

```json
POST /mcp
{
    "jsonrpc": "2.0",
    "method": "route.add",
    "params": {
        "prefix": "10.0.0.0/24",
        "via": "192.168.1.1"
    },
    "id": 1
}
```

## 4. IPC Call Example (Go)

```go
req := Request{
    ID:      "1",
    Command: "route add",
    Args:    []string{"prefix=10.0.0.0/24", "via=192.168.1.1"},
}
client.Send(req)
```

---

# âš™ï¸ REPL DSL Flowchart

```mermaid
sequenceDiagram
    participant U as User
    participant R as REPL/DSL
    participant I as IPC Client
    participant D as Daemon
    participant M as runtime.Manager
    participant MOD as Module

    U->>R: è¾“å…¥ DSL å‘½ä»¤
    R->>R: è§£ææˆ AST
    R->>I: æ‰“åŒ…æˆ IPC è¯·æ±‚
    I->>D: å‘é€ DSL Request
    D->>M: ExecDSL()
    M->>MOD: è°ƒç”¨å¯¹åº”æ¨¡å—
    MOD->>M: è¿”å›ç»“æœ
    M->>D: å“åº”
    D->>I: è¿”å›ç»“æœ
    I->>U: è¾“å‡ºæ¸²æŸ“å¥½çš„ç»“æœ
```

---

# ğŸ”¹ REST / MCP Flowchart
```mermaid
sequenceDiagram
    participant Client as REST / MCP
    participant Daemon as flyos-daemon
    participant Runtime as runtime.Manager
    participant Module as æ¨¡å—ç»„

    Client->>Daemon: JSON è¯·æ±‚ (REST / MCP)
    Daemon->>Runtime: Exec(cmd, args)
    Runtime->>Module: è°ƒç”¨å¯¹åº”æ¨¡å—
    Module-->>Runtime: è¿”å›æ‰§è¡Œç»“æœ
    Runtime-->>Daemon: stdout / stderr
    Daemon-->>Client: JSON / JSON-RPC å“åº”
```
---

# âš™ï¸ Runtime call chain diagram

```mermaid
flowchart TD

    REST[REST/MCP/REPL è¾“å…¥] --> IPC[IPC Request]
    IPC --> DAEMON[flyos-daemon]
    DAEMON --> RM[runtime.Manager]
    RM --> DISPATCH{æ¨¡å—åˆ†å‘}
    DISPATCH --> ROUTE[Routing Module]
    DISPATCH --> ACL[ACL Module]
    DISPATCH --> NAT[NAT Module]
    DISPATCH --> NIC[NIC Module]
    DISPATCH --> TUN[Tunnel Module]
    DISPATCH --> VRF[VRF Module]
```

---

# ğŸ§± Module Architecture Diagram

```mermaid
graph TB

    MGR[runtime.Manager]

    subgraph Modules
        RT[Routing]
        AC[ACL]
        NA[NAT]
        NC[NIC]
        TU[Tunnel]
        VF[VRF]
    end

    MGR --> RT
    MGR --> AC
    MGR --> NA
    MGR --> NC
    MGR --> TU
    MGR --> VF
```
---

# ğŸ—’ï¸ TODO

- [ ] REPL Login / ACL
- [ ] REST OpenAPI
- [ ] MCP schema auto-generation
- [ ] CLI/REPL history and completion
- [ ] modules generate unified documentation